# В1
Рекурсивная функция для вычисления суммы цифр числа.

# Алгоритм основан на рекурсивном подходе и работает следующим образом:

    Базовый случай: если число равно 0, возвращаем 0.

    Рекурсивный случай:

        Берем последнюю цифру числа с помощью операции n % 10.

        Отбрасываем последнюю цифру с помощью целочисленного деления n // 10 (или n / 10 в C++/Java).

        Рекурсивно вызываем функцию для оставшейся части числа.

        Складываем текущую последнюю цифру с результатом рекурсивного вызова.

## Временная сложность

Временная сложность алгоритма: O(d), где d — количество цифр в числе.
Почему такая сложность

    На каждом шаге алгоритма мы:

        Выполняем константное количество операций (деление, остаток, сложение).

        Уменьшаем размер числа в 10 раз (отбрасываем одну цифру).

    Количество рекурсивных вызовов равно количеству цифр в числе.

    Таким образом, если число имеет d цифр, алгоритм выполнит d рекурсивных вызовов, каждый из которых занимает константное время.

## Пример работы алгоритма

Рассмотрим работу алгоритма на примере числа 123:

    sum_of_digits(123) → 3 + sum_of_digits(12)

    sum_of_digits(12) → 2 + sum_of_digits(1)

    sum_of_digits(1) → 1 + sum_of_digits(0)

    sum_of_digits(0) → 0 (базовый случай)

    Результат: 3 + 2 + 1 + 0 = 6

## Важные замечания

    Алгоритм корректно работает с отрицательными числами благодаря использованию abs().

    Для больших чисел количество рекурсивных вызовов может привести к переполнению стека.

    Альтернативой может служить итеративный подход, который не имеет ограничений по глубине рекурсии.
